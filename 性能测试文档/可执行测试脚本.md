# 故障注入可执行测试脚本集（Linux 环境）

本文档提供 **5 类核心故障场景的可执行脚本**，所有脚本均基于 Linux 系统设计，需提前确认环境依赖（工具安装、权限配置），并严格遵循 “先备份、先预演、再执行” 的原则，避免影响业务系统。

## 一、脚本通用前提条件

1. **环境要求**：CentOS 7+/Ubuntu 18.04+（其他 Linux 发行版需调整工具安装命令）；
2. **权限要求**：所有脚本需以 `root` 或 `sudo` 权限执行（涉及系统资源、进程管理）；
3. **工具预装**：执行前确保依赖工具已安装，缺失时可参考下表快速安装：

| 依赖工具        | 安装命令（CentOS）                                                                           | 安装命令（Ubuntu）                 |
| --------------- | -------------------------------------------------------------------------------------------- | ---------------------------------- |
| stress-ng       | `yum install -y stress-ng`                                                                 | `apt-get install -y stress-ng`   |
| tc（流量控制）  | 系统自带（内核模块 `sch_netem`）                                                           | 系统自带（内核模块 `sch_netem`） |
| ChaosBlade      | 参考[官方](https://chaosblade.io/docs/installation)[文档](https://chaosblade.io/docs/installation) | 同左                               |
| jq（JSON 解析） | `yum install -y jq`                                                                        | `apt-get install -y jq`          |
| redis-cli       | `yum install -y redis`                                                                     | `apt-get install -y redis-tools` |

## 二、分场景可执行脚本

### 场景 1：硬件故障 - CPU 高负载注入脚本

#### 脚本功能

模拟 “单 / 多核心 CPU 使用率维持在 90%±5%” 的高负载场景，用于验证服务在 CPU 资源紧张时的稳定性。

#### 1.1 执行脚本（`cpu-high-load.sh`）


```
\#!/bin/bash

\# 脚本参数：\$1=CPU核心数（如4） \$2=负载持续时间（秒，如300） \$3=负载百分比（如90）

\# 示例：./cpu-high-load.sh 4 300 90（4核CPU，维持90%负载300秒）

\# 参数校验

if \[ \$# -ne 3 ]; then

  echo "Usage: \$0 \<cpu\_cores> \<duration\_seconds> \<load\_percent>"

  exit 1

fi

CPU\_CORES=\$1

DURATION=\$2

LOAD\_PERCENT=\$3

\# 检查stress-ng是否安装

if ! command -v stress-ng &> /dev/null; then

  echo "Error: stress-ng is not installed. Install first with 'yum install -y stress-ng'."

  exit 1

fi

\# 记录进程ID，用于后续回滚

STRESS\_PID=\$(stress-ng --cpu \$CPU\_CORES --cpu-load \$LOAD\_PERCENT --timeout \$DURATION --pidfile /tmp/stress-cpu.pid & echo \$!)

echo "CPU high load injected: \$CPU\_CORES cores, \$LOAD\_PERCENT% load, duration \$DURATION seconds."

echo "Stress PID: \$STRESS\_PID (save for rollback)."
```

#### 1.2 回滚脚本（`cpu-high-load-rollback.sh`）

```
\#!/bin/bash

\# 停止所有stress-ng进程，恢复CPU正常状态

\# 查找stress-ng进程并终止

STRESS\_PIDS=\$(ps aux | grep stress-ng | grep -v grep | awk '{print \$2}')

if \[ -n "\$STRESS\_PIDS" ]; then

  for PID in \$STRESS\_PIDS; do

    kill -9 \$PID

    echo "Killed stress-ng PID: \$PID"

  done

else

  echo "No stress-ng processes found."

fi

\# 删除PID文件

rm -f /tmp/stress-cpu.pid

echo "CPU load rolled back to normal."
```

#### 注意事项

* 避免在生产核心服务器上执行（优先预发环境）；
* 若需长期测试（超过 10 分钟），需提前监控内存是否泄漏（stress-ng 低概率存在内存占用增长）。

### 场景 2：网络故障 - 延迟 + 丢包注入脚本

#### 脚本功能

模拟 “指定网卡的网络延迟（如 300ms）+ 丢包率（如 5%）”，用于验证服务在弱网络环境下的容错能力（如订单服务→MySQL 的网络链路）。

#### 2.1 执行脚本（`network-delay-loss.sh`）

```
#!/bin/bash

# 脚本参数：\$1=网卡名称（如eth0） \$2=延迟时间（ms，如300） \$3=丢包率（%，如5） \$4=延迟抖动（ms，如50）

# 示例：./network-delay-loss.sh eth0 300 5 50（eth0网卡，300ms延迟+5%丢包+50ms抖动）

if [ $# -ne 4 ]; then

  echo "Usage: \$0 \<network\_interface> \<delay\_ms> \<loss\_percent> \<jitter\_ms>"

  exit 1

fi

INTERFACE=\$1

DELAY=\$2

LOSS=\$3

JITTER=\$4

# 检查网卡是否存在

if ! ip link show \$INTERFACE &> /dev/null; then

  echo "Error: Network interface \$INTERFACE does not exist."

  exit 1

fi

# 清除原有tc规则（避免冲突）

tc qdisc del dev \$INTERFACE root &> /dev/null

# 注入延迟+丢包规则

tc qdisc add dev \$INTERFACE root netem delay \$DELAY ms \$JITTER ms loss \$LOSS%

echo "Network fault injected: \$INTERFACE interface, \$DELAY ms delay (+\$JITTER ms jitter), \$LOSS% packet loss."

echo "Check with 'tc qdisc show dev \$INTERFACE'."
```

#### 2.2 回滚脚本（`network-delay-loss-rollback.sh`）

```
#!/bin/bash

# 脚本参数：\$1=网卡名称（如eth0）

# 示例：./network-delay-loss-rollback.sh eth0

if [ \$# -ne 1 ]; then

  echo "Usage: \$0 \<network\_interface>"

  exit 1

fi

INTERFACE=\$1

# 清除tc规则，恢复网络正常

tc qdisc del dev \$INTERFACE root &> /dev/null

if [ \$? -eq 0 ]; then

  echo "Network rules rolled back: \$INTERFACE interface."

else

  echo "No tc rules found for \$INTERFACE."

fi
```

#### 注意事项

* 执行前记录网卡原有 tc 规则（`tc qdisc show dev 网卡名`），避免回滚不彻底；
* 若测试 “跨服务链路”（如服务 A→服务 B），需在**服务 A 的出口网卡**或**服务 B 的入口网卡**注入，避免影响其他链路。

### 场景 3：中间件故障 - Redis 主节点宕机注入脚本

#### 脚本功能

用 ChaosBlade 精准停止 Redis 主节点进程（非暴力 kill，支持优雅回滚），验证服务的缓存降级能力（如商品服务从数据库降级查询）。

#### 3.1 执行脚本（`redis-master-down.sh`）

```
\#!/bin/bash

\# 脚本参数：\$1=Redis主节点IP \$2=Redis端口 \$3=故障持续时间（秒，如180）

\# 示例：./redis-master-down.sh 10.0.0.10 6379 180（停止10.0.0.10:6379的Redis，持续180秒）

if \[ \$# -ne 3 ]; then

  echo "Usage: \$0 \<redis\_ip> \<redis\_port> \<duration\_seconds>"

  exit 1

fi

REDIS\_IP=\$1

REDIS\_PORT=\$2

DURATION=\$3

\# 检查ChaosBlade是否安装

if ! command -v blade &> /dev/null; then

  echo "Error: ChaosBlade is not installed. Refer to https://chaosblade.io/docs/installation."

  exit 1

fi

\# 检查Redis是否存活

if ! redis-cli -h \$REDIS\_IP -p \$REDIS\_PORT ping &> /dev/null; then

  echo "Error: Redis \$REDIS\_IP:\$REDIS\_PORT is already down."

  exit 1

fi

\# 注入Redis宕机故障（记录实验ID，用于回滚）

EXPERIMENT\_ID=\$(blade create redis stop -h \$REDIS\_IP -p \$REDIS\_PORT --timeout \$DURATION --yes | grep "experiment ID" | awk '{print \$4}')

echo "Redis fault injected: \$REDIS\_IP:\$REDIS\_PORT stopped, duration \$DURATION seconds."

echo "ChaosBlade Experiment ID: \$EXPERIMENT\_ID (save for rollback)."
```

#### 3.2 回滚脚本（`redis-master-down-rollback.sh`）

```
\#!/bin/bash

\# 脚本参数：\$1=ChaosBlade实验ID（从执行脚本输出中获取）

\# 示例：./redis-master-down-rollback.sh 522222c8-xxxx-xxxx-xxxx-xxxxxxxxxxxx

if \[ \$# -ne 1 ]; then

  echo "Usage: \$0 \<chaosblade\_experiment\_id>"

  exit 1

fi

EXPERIMENT\_ID=\$1

\# 停止ChaosBlade实验，恢复Redis

blade destroy \$EXPERIMENT\_ID --yes

if \[ \$? -eq 0 ]; then

  echo "Redis fault rolled back: Experiment \$EXPERIMENT\_ID destroyed."

  \# 验证Redis是否恢复

  REDIS\_IP=\$(blade status \$EXPERIMENT\_ID | grep "redis\_ip" | awk -F': ' '{print \$2}')

  REDIS\_PORT=\$(blade status \$EXPERIMENT\_ID | grep "redis\_port" | awk -F': ' '{print \$2}')

  if redis-cli -h \$REDIS\_IP -p \$REDIS\_PORT ping &> /dev/null; then

    echo "Redis \$REDIS\_IP:\$REDIS\_PORT is now alive."

  fi

else

  echo "Error: Failed to rollback experiment \$EXPERIMENT\_ID."

fi
```

#### 注意事项

* 执行前确保 Redis 主从同步正常（避免故障后数据丢失）；
* ChaosBlade 的 `--timeout`参数会自动回滚，手动回滚仅用于紧急场景。

### 场景 4：数据库故障 - MySQL 连接池耗尽注入脚本

#### 脚本功能

通过 JMX 修改 Spring Boot 应用的 MySQL 连接池最大数（从 100 改为 10），模拟连接池耗尽，验证服务的限流降级能力（如返回 “系统繁忙”）。

#### 4.1 执行脚本（`mysql-connection-pool-exhaust.sh`）

```
\#!/bin/bash

\# 脚本参数：\$1=应用IP \$2=JMX端口 \$3=原连接池最大数 \$4=目标连接池最大数

\# 示例：./mysql-connection-pool-exhaust.sh 10.0.0.20 9999 100 10（将10.0.0.20:9999的应用连接池从100改为10）

if \[ \$# -ne 4 ]; then

  echo "Usage: \$0 \<app\_ip> \<jmx\_port> \<original\_max\_size> \<target\_max\_size>"

  exit 1

fi

APP\_IP=\$1

JMX\_PORT=\$2

ORIGINAL\_MAX=\$3

TARGET\_MAX=\$4

\# 检查jmxterm是否安装（用于JMX调用）

if ! command -v jmxterm &> /dev/null; then

  echo "Error: jmxterm is not installed. Install first with 'wget https://github.com/jiaqi/jmxterm/releases/download/v1.0.4/jmxterm-1.0.4-uber.jar -O /usr/local/bin/jmxterm && chmod +x /usr/local/bin/jmxterm'."

  exit 1

fi

\# 记录原配置（用于回滚）

echo "\$APP\_IP \$JMX\_PORT \$ORIGINAL\_MAX" > /tmp/mysql-pool-original.conf

\# 通过JMX修改HikariCP连接池最大数（适用于Spring Boot 2.x+）

jmxterm -n -l \$APP\_IP:\$JMX\_PORT -e "bean com.zaxxer.hikari:type=PoolConfig (HikariPool-1); set maxPoolSize \$TARGET\_MAX; exit" &> /dev/null

if \[ \$? -eq 0 ]; then

  echo "MySQL connection pool injected: \$APP\_IP:\$JMX\_PORT max size changed from \$ORIGINAL\_MAX to \$TARGET\_MAX."

else

  echo "Error: Failed to modify connection pool size. Check JMX port and app status."

  exit 1

fi
```

#### 4.2 回滚脚本（`mysql-connection-pool-rollback.sh`）

```
\#!/bin/bash

\# 脚本参数：\$1=应用IP \$2=JMX端口（从原配置文件读取，也可手动传入）

\# 示例：./mysql-connection-pool-rollback.sh 10.0.0.20 9999

if \[ \$# -ne 2 ]; then

  echo "Usage: \$0 \<app\_ip> \<jmx\_port>"

  exit 1

fi

APP\_IP=\$1

JMX\_PORT=\$2

\# 读取原连接池配置

ORIGINAL\_MAX=\$(grep "\$APP\_IP \$JMX\_PORT" /tmp/mysql-pool-original.conf | awk '{print \$3}')

if \[ -z "\$ORIGINAL\_MAX" ]; then

  echo "Error: Original pool size not found. Check /tmp/mysql-pool-original.conf."

  exit 1

fi

\# 恢复连接池最大数

jmxterm -n -l \$APP\_IP:\$JMX\_PORT -e "bean com.zaxxer.hikari:type=PoolConfig (HikariPool-1); set maxPoolSize \$ORIGINAL\_MAX; exit" &> /dev/null

if \[ \$? -eq 0 ]; then

  echo "MySQL connection pool rolled back: \$APP\_IP:\$JMX\_PORT max size restored to \$ORIGINAL\_MAX."

  \# 删除原配置文件

  rm -f /tmp/mysql-pool-original.conf

else

  echo "Error: Failed to rollback connection pool size."

fi
```

#### 注意事项

* 应用需开启 JMX（启动参数添加 `-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9999 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false`）；
* 若使用其他连接池（如 Druid），需修改 JMX bean 路径（如 `com.alibaba.druid.pool:type=DruidDataSource,id=1`）。

### 场景 5：数据故障 - 脏数据注入脚本（MySQL）

#### 脚本功能

向 MySQL 订单表插入 “金额为负数” 的脏数据，验证服务是否有数据校验逻辑（如订单创建时拒绝负数金额）。

#### 5.1 执行脚本（`mysql-dirty-data.sh`）

```
\#!/bin/bash

\# 脚本参数：\$1=MySQL IP \$2=MySQL端口 \$3=数据库名 \$4=用户名 \$5=密码

\# 示例：./mysql-dirty-data.sh 10.0.0.30 3306 order\_db root 123456（向order\_db插入负数金额订单）

if \[ \$# -ne 5 ]; then

  echo "Usage: \$0 \<mysql\_ip> \<mysql\_port> \<db\_name> \<db\_user> \<db\_pass>"

  exit 1

fi

MYSQL\_IP=\$1

MYSQL\_PORT=\$2

DB\_NAME=\$3

DB\_USER=\$4

DB\_PASS=\$5

\# 检查MySQL连接

if ! mysql -h \$MYSQL\_IP -P \$MYSQL\_PORT -u \$DB\_USER -p\$DB\_PASS -e "use \$DB\_NAME;" &> /dev/null; then

  echo "Error: Failed to connect to MySQL \$MYSQL\_IP:\$MYSQL\_PORT/\$DB\_NAME."

  exit 1

fi

\# 生成随机订单号（避免重复）

ORDER\_NO="DIRTY\_\$(date +%Y%m%d%H%M%S)\_\$((\$RANDOM % 1000))"

\# 插入脏数据（金额为-100元，用户ID=99999）

MYSQL\_CMD="INSERT INTO \${DB\_NAME}.orders (order\_no, user\_id, amount, create\_time) VALUES ('\$ORDER\_NO', 99999, -100, NOW());"

mysql -h \$MYSQL\_IP -P \$MYSQL\_PORT -u \$DB\_USER -p\$DB\_PASS -e "\$MYSQL\_CMD"

if \[ \$? -eq 0 ]; then

  echo "Dirty data injected: MySQL \$MYSQL\_IP:\$MYSQL\_PORT/\$DB\_NAME.orders, order\_no=\$ORDER\_NO (amount=-100)."

  \# 记录脏数据ID，用于回滚

  echo "\$ORDER\_NO" > /tmp/mysql-dirty-order-no.conf

else

  echo "Error: Failed to inject dirty data."

  exit 1

fi
```

#### 5.2 回滚脚本（`mysql-dirty-data-rollback.sh`）

```
\#!/bin/bash

\# 脚本参数：\$1=MySQL IP \$2=MySQL端口 \$3=数据库名 \$4=用户名 \$5=密码

\# 示例：./mysql-dirty-data-rollback.sh 10.0.0.30 3306 order\_db root 123456

if \[ \$# -ne 5 ]; then

  echo "Usage: \$0 \<mysql\_ip> \<mysql\_port> \<db\_name> \<db\_user> \<db\_pass>"

  exit 1

fi

MYSQL\_IP=\$1

MYSQL\_PORT=\$2

DB\_NAME=\$3

DB\_USER=\$4

DB\_PASS=\$5

\# 读取脏数据订单号

if \[ ! -f /tmp/mysql-dirty-order-no.conf ]; then

  echo "Error: Dirty data order no not found. Check /tmp/mysql-dirty-order-no.conf."

  exit 1

fi

ORDER\_NO=\$(cat /tmp/mysql-dirty-order-no.conf)

\# 删除脏数据

MYSQL\_CMD="DELETE FROM \${DB\_NAME}.orders WHERE order\_no='\$ORDER\_NO';"

mysql -h \$MYSQL\_IP -P \$MYSQL\_PORT -u \$DB\_USER -p\$DB\_PASS -e "\$MYSQL\_CMD"

if \[ \$? -eq 0 ]; then

  echo "Dirty data rolled back: MySQL \$MYSQL\_IP:\$MYSQL\_PORT/\$DB\_NAME.orders, order\_no=\$ORDER\_NO deleted."

  \# 删除记录文件

  rm -f /tmp/mysql-dirty-order-no.conf

else

  echo "Error: Failed to delete dirty data. Check if order\_no exists."

fi
```

#### 注意事项

* **必须在测试环境执行**，生产环境严禁注入脏数据；
* 执行前确认订单表结构（字段名如 `order_no`、`amount`）与脚本一致，不一致需修改 SQL 语句。

## 三、脚本使用安全 checklist

1. **执行前**：

备份目标系统数据（如 MySQL 全量备份、Redis RDB 持久化）；

确认测试环境与生产环境隔离（非核心业务集群）；

通知相关团队（开发、运维），确认监控正常；

1. **执行中**：

实时观测业务指标（如接口成功率、错误率），异常时立即回滚；

不随意修改脚本参数（如扩大 CPU 核心数、延长故障 duration）；

1. **执行后**：

执行回滚脚本，确认系统恢复正常（如 Redis 存活、CPU 负载降至 20% 以下）；

删除临时文件（如 `/tmp/stress-cpu.pid`、`/tmp/mysql-dirty-order-no.conf`）；

记录测试结果（如 “CPU 高负载时，接口响应时间从 200ms 升至 450ms，无超时”）。

> （注：文档部分内容可能由 AI 生成）
